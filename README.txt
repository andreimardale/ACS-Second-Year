== README-Tema2-Protocoale de Comunicatii ==
== MARDALE ANDREI == 324 CB

===== Aplicatia SERVER =====

Pentru a dezvolta serverul am facut o clasa speciala numita Info. Am folosit aceasta clasa pentru a tine toate informatiile necesare pentru un user, astfel clasa Info tine un string parola si doi vectori de string pentru listele de fisiere partajate si private. Clasa mai contine functiile findInPrivate si findInShared care returneaza un boolean ce indica daca un fisier e privat sau nu. Functiile set_shared si unset_Shared sunt folosite pentru a seta un fisier ca Shared sau Private. Practic, ce fac ele este sa scoata un fisier din o anumita lista si sa il introduca in cealalta lista. Am folosit un map global (unordered_map) pentru a avea acces rapid, in O(1). Acesta mapeaza socket-ul unei conexiuni cu userul logat de pe acea conexiune. E folosit pentru a vedea ce useri sunt logati pe server la un moment dat. Variabila globala boolean TO_QUIT are rolul de a retine daca s-a dat comanda QUIT, in timpul unui transfer, iar daca a fost declansata aceasta comanda, atunci la finalul ultimului transfer se inchide servererul. Variabila BLOCK_CMD este setata atunci cand nu se mai pot primi comenzi din partea clientilor, adica dupa o comanda quit pe server.
Functia is_not_alnum_space verifica ca un caracter sa fie alfanumeric, e folosita pentru validare. 
Functia checkName verifica daca sunt indeplinite conditiile pentru un username sau o parola (dimensiune si caractere alfanumerice si spatii).
Functia split -> primeste un string si un separator si separa acel string in tokeni.
Functia populateUsers -> populeaza lista cu useri si parolele lor citite din fisierul de input.
Functia populateFiles -> populeaza fisierele share-uite pe baza fisierului de input. Citeste cate un rand, face split dupa ":", si verifica daca userul exista deja, daca nu exista inca, atunci verifica daca fisierul specificat exista pe disc. Daca exista, se populeaza lista de sharedFiles din cadrul clasei Info specifica numelui "user".
Functia populatePrivateFiles -> Verifica un director anume si toate fisierele care nu sunt partajate le considera private si le insereaza numele in lista aferenta.
checkLogin -> verifica datele de login. Intoarce 1 daca nu exist acel user, 2 pentru parola gresita si 0 pt conexiune acceptata. In momentul cand se accepta o conexiune, atunci se mapeaza socket-ul aferent ei cu username-ul pentru a sti exact fiecare utilizator pe ce canal comunica.
createFolders -> creeaza folderele la inceputul rularii serverului, daca acestea nu exista deja.
fsize -> determina dimensiunea unui fisier folosind functia stat()
prettyFormat -> afiseaza mai placut dimensiunea unui fisier, punand '.' la fiecare 3 digiti.
fileInfo -> intoarce informatii despre fisierele dintr-un director (dimensiune si starea lor -> shared/private). Folosesc functia readdir() si determin toate fisierele. Pentru fiecare fisier apelez fsize() pentru a determina dimensiunea si verific daca e Shared / Private. Se returneaza rezultatul ca un string din care scot ultimul '\n'.
unwrapName -> Functie care scoate padding-ul adaugat pentru un antet de bucata de fisier trimis la upload / download.
increment -> incremeanteaza contorul circular pentru politica de round robin, pe baza dimensiunii listei de fisiere in curs de transfer.
sendAll -> wrapper peste send(). Asigura trimiterea totala a datelor. Am avut o mare problema aici, pana sa aflu ca TCP, mai exact send() si recv() nu garanteaza faptul ca vei primi imediat atati bytes cat se zice. Astfel, cel mai indicat este sa repeti operatiunea de send ()/ recv() intr-un while, pana primesti atati bytes cat iti doresti. Exact acest lucru il face sendAll().
recvAll() -> wrapper peste recv(). Analog cu sendAll(), asigura primirea totala a datelor.
-> MAIN() <-
Voi prezenta succint ce se intampla in main(), apoi voi detalia protocolul ales de mine, pentru implementarea acestei teme.
Mai intai, in main() verific ca numarul de parametrii sa fie respectat. Apoi, populez pe rand, listele de useri, creez folderele, populez listele de fisiere private si Shared. Golesc multimile de descriptori folosite pentru select(). Creez un socket pe care se vor primi conexiuni, e un socket inactiv. Fac bind pe socket-ul deschis anterior si ascult cereri din partea clientilor. Adaug noul file descriptor (socketul pe care se asculta conexiuni) in multimea read_fds si descriptorul pentru STDIN. Setez structura de time-out pentru multiplexarea cu select(). Prin teste succesive, am ales sa setez time-out la 90 microsecunde. Ideea implementata este urmatoarea: tot programul se deruleaza intr-un while (1). La un moment dat, eu pot multiplexa intre a primi date sau a trimite date, avand active atat multimea de citire cat si de scriere de fd. Daca a trecut un timp de 90 microsecunde si nu s-a mai dat nicio alta comanda si select() a ales sa trimita o bucata de fisier, atunci se trimite. Acel timeout impiedica practic serverul sa trimita prea repede bucati de fisier catre clienti, caz in care experienta este una EXTREM de blocanta... Revenind la receptionare: daca se alege sa se receptioneze un mesaj: atunci el poate fi pe sockfd, adica pe socket-ul inactiv pe care se stabilesc conexiunile initiale (cand se conecteaza un client nou la server), sau poate fi un mesaj de la tastatura, (in cazul in care se da quit()) sau poate fi un mesaj de la client. In primul caz, in care primeste ceva pe socketul inactiv, cel cu listen, inseamna ca am o noua conexiune. In acest caz, serverul face accept() si adauga noul socket in multimile aferente. Tot acum se adauga acel socket in lista de clienti. In cazul 2, in care se primeste ceva de la tastatura, acel ceva este un mesaj de tip quit pe server. Daca nu exista transferuri in curs, adica listele for_dld si receving sunt goale, atunci se atentioneaza direct, toti clientii ca serverul se va inchide si se inchide. Altfel, se seteaza cu true BLOCK_CMD, astfel incat sa nu se mai poata primi comenzi si se setea cu true si TO_QUIT. Astfel, la ultimul transfer efectuat cu succes, serverul se va inchide.
A treia posibilitate: serverul primeste un mesaj de la unul din clienti: aici, in functie de ce tip de comanda este primita, se iau diferite decizii. In primul rand se face recvAll() pentru a se primi tot mesajul. Se fac verificari pentru a vedea daca conexiunea s-a inchis. Daca mesajul e unul complet atunci se iau diferite decizii. Protocolul implementat de mine impune un header la inceputul fiecarui mesaj primit / trimis prin upload/download. Acest antet are o dimensiune fixa, 49 de octeti, folositi astfel: "piece-NumeFisierCuPadding-dimensiune". "piece" e folosit pentru a diferentia strict intre un mesaj primit ca parte a unui transfer si unul primit si o comanda efectiva. Numele fisierului, in implementarea mea e limitat la 40 de caractere. Daca are o lungime mai mica, atunci se aplica un padding pana la 40 de caractere. Ex: test@@@@@...@@@. Apoi inca 4 octeti sunt reprezentati de dimensiunea efectiva a mesajul util. Acest lucru e folosit la destinatie, pentru a sti cat exact trebuie folosit din acel payload. Am folosit 4 cifre pentru ca oricum dimensiunea maxima a unui mesaj e 4096, deci nu poate fi mai mare de 4 cifre. Acesta a fost header-ul si se aplica invariant, la toate bucatile de mesaj de tip upload/download. Astfel, daca mesajul incepe cu "piece" stiu ca este o bucata de mesaj primit ca parte dintr-un upload. Se determina fisierul si dimensiunea utila a mesajul. Daca in loc de dimensiune apare textul "done", inseamna ca acela a fost sfarsitul transmisiei si se poate scoate din lista de primiri acel fisier se poate inchide fisierul pe disc si se trimite inapoi clientului un mesaj ce va fi afisat direct de catre acesta. Upload finished.... impreuna cu dimensiunea fisierului. Cand se termina un transfer, e important de vazut daca a fost setata TO_QUIT si daca a fost setat, atunci se va inchide serverul imediat ce ultimul transfer in curs a fost finalizat. Daca mesajul nu e cel final, atunci se scrie in fisier bucata de date care a sosit. 
Pentru orice alte comenzi: Daca BLOCK_CMD nu e true, atunci preiau mesajul si il splituiesc.
Daca primul cuvant e login, atunci verific daca datele sunt introduse corect si daca sunt ok, atunci trimit codul "0", daca nu, trimit un cod de eroare. La fiecare incercare gresita se incrementeaza un contor aferent fiecarui socket. Daca acesta ajunge la 3 -> brute force.
Daca primul cuvant e logout, tot ce se face este sa se stearga userul asociat socket-ului respectiv din liste de useri logati.
Daca primul cuvant e getuserlist, atunci se parcurge lsita de usereri si se construieste raspunsul. Acesta este prefixat de litera 'l', apoi se trimite mesajul.
Daca primul cuvant este getfilelist, atunci se verifica daca exista acel utilizator pentru care se vrea lista de fisiere. Daca nu exista se trimite mesaj de eroare. Daca exista, atunci se obtin informatii cu functia fileInfo se se trimit catre client.
Daca primul cuvant a fost "share", atunci se determina fisierul share-uit. Nu folosesc functia de split, ci folosesc faptul ca am un offset de 6 caractere pana la numele fisierului, pentru ca numele poate contine spatii albe. Se obtin informatii din structura Info. Daca fisierul respectiv nu exista sau e deja share-uit se intoarce eroarea aferenta. Altfel, se seteaza ca fiind partajat si se trimite clientului un mesaj de confirmare.
Daca primul cuvant a fost "unshare", actiunile sunt asemanatoare ca la share.
Daca primul cuvant a fost "upload", atunci se determina numele fisierului, calea catre fisier si se verifica daca fisierul exista deja pe server. Daca exista, se trimite clientului un mesaj cu antet "u0", ceea ce indica ca fisierul exista deja. Daca totul e in regula, se trimite clientului mesaj cu antet "u1", ceea ce ii indica clientului ca poate incepe transferul bucatilor de fisier. Tot acum, se deschide fisierul pe disc si se mapeaza numele fisierului cu un fd, folosind un map. Se insereaza numele fisierului in lista de primiri (receving). 
Daca primul cuvant este "delete", atunci se determina numele fisierului, calea si se verifica daca fisierul este in curs de upload sau download, caz in care se trimite un mesaj aferent. Daca fisierul nu e implicat in niciun transfer, atunci se sterge fisierul de pe disc. 
Daca primul cuvant este "download", atunci se determina user-ul proprietar al acelui fisier si fisierul. Se verifica daca exista fisierul pe server, daca nu exista se trimite un antet de forma "D0". Daca exista fisierul dar e privat, am antet de forma "D1". Daca totul e ok, se trimite un antet de forma D2, care instiinteaza clientul ca download-ul este ok si poate continua procedura. 
Daca primul cuvant e "start", inseamna ca, clientul a luat la cunostinta de faptul ca downloadul e ok, si-a creat fisierul pe disc si asteapta sa primeasca bucati de fisier. In acest moment, serverul determina posesorul fisierului, substituie @ cu numele real, deschide fisierul pentru citire si introduce in lista de trimiteri un tuplu de forma (nume_fisier, socket, fd). Din aceasta lista se vor lua bucati conform cu politica round-robin.
Daca primul cuvant e "quit", inseamna ca s-a primit quit pe client si se sterge acel client din lista de clienti si se scoate socket-ul din multimea de descriptori. 
Acestea au fost cazurile in care serverul primeste un mesaj. 
Daca select() alege sa se trimita un mesaj, se verifica intai daca timeerul a ajuns la 0. Daca lista de trimiteri nu e goala, atunci se selecteaza un tuplu pentru trimitere. Se citeste din fisier-ul indicat de fd, un numar de BUFLEN-dim_antet bytes. Daca s-a terminat de citit, m <= 0, atunci se trimite un mesaj de informare, cu dimensiunea "done". In acest caz se si sterge din lista de trimiteri acel fisier si se inchide fisierul sursa. Acum se verifica si daca TO_QUIT a fost setat intre timp. Daca a fost citit ceva diferit de 0 din fisierul sursa, atunci se adauga un padding la nume, se ataseaza antetul si datele efective si se trimite.


===== Aplicatia CLIENT =====
Obs: In mare parte, aplicatia client a fost realizata in oglinda cu serverul din punctul de vedere al operatiilor de transfer al fisierelor.
Functii auxiliare folosite : cam aceleasi ca la server, in plus am functia printPromt (), care afiseaza promtul.
In main(), fac operatii de pregatire a conexiunii. Setez timer, la fel ca la server. Clientul e gandit astfel: La un moment dat, select() poate multiplexa intre a primi sau a trimite date. Daca se alege sa se primeasca, se pot primi date de la socketul pe care se comunica cu serverul, sau de la tastatura. Daca se alege sa se trimita date, prin upload, atunci trebuie sa treaca un timp de 90 micro secunde intre doua trimiteri consecutive. Daca se alege sa se primeasca ceva de la server, atunci daca primul cuvant e piece, inseaman ca e o bucata dintr-un download, caz in care se procedeaza similar ca pe server. Orice alt mesaj, este afisat direct, deoarece reprezinta un feedback de la server. Daca se primeste ceva de pe STDIN, atunci se proceseaza comanda si se trimite catre server.
Daca se alege sa se scrie ceva, atunci, se procedeaza ca pe server.